% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mod.R
\name{asr}
\alias{asr}
\title{Fit a genetic-spatial competition model}
\usage{
asr(prep.out, fixed, random = ~1, cor = TRUE, lrtest = FALSE, ...)
}
\arguments{
\item{prep.out}{A \code{comprep} object.}

\item{fixed}{A formula object specifying the fixed terms in the model, with the
response on the left of a \code{~} operator, and the terms,
separated by + operators, on the right. If \code{data} is given,
all names used in all formulae should appear in the data frame. A
model with the intercept as the only fixed effect can be specified
as \code{~ 1}; there must be at least one fixed effect
specified. If the response (\emph{y}) evaluates to a matrix then a
factor \code{trait} with levels \code{dimnames(y)[[2]]} is added to
the model frame, and must be explicitly included in the model
formulae (default = \code{NULL}).}

\item{random}{The function is set to fit the genetic competition models in the
\code{random} term. To consider further random effects, \code{random} receives a formula
object specifying them. Otherwise, \code{random = ~1} (default). This argument has
the same general characteristics as fixed, but there can be no left side to
the ~ operator. Variance structures imposed on random terms are specified using
special model functions. See \code{\link[asreml:asreml]{asreml::asreml()}} for details.}

\item{cor}{A logical value. If \code{TRUE} (default), fits a model considering the correlation
between direct and indirect genetic effects.}

\item{lrtest}{A logical value. If \code{TRUE}, performs a likelihood ratio test to verify
the significance of the direct and indirect genetic effects. Defaults to \code{FALSE}.}

\item{...}{
  Arguments passed on to \code{\link[asreml:asreml]{asreml::asreml}}
  \describe{
    \item{\code{sparse}}{A formula object, specifying the fixed effects for which the full
variance-covariance matrix is not required. This argument has the
same general characteristics as \code{fixed}, but there can be no
left side to the \code{~} expression. Wald statistics are not
available for sparse fixed terms in order to reduce the computing
load (default = \code{~NULL}).}
    \item{\code{G.param}}{Either:

\itemize{

\item A list object derived from the
\code{random} formula, holding initial parameter estimates and
boundary constraints for each term, or

\item A character string naming a comma-delimited file with a
header line and three columns for the variance component name,
initial value and constraint code, respectively. This file can be
created using the \code{start.values = TRUE} argument; the internal list
object is then generated from the contents of this file.
}

On termination, \code{G.param} is updated with the final
\code{random} component estimates.}
    \item{\code{R.param}}{Either:

\itemize{

\item A list object derived from the \code{random} formula, holding
initial parameter estimates and boundary constraints, or

\item A character string naming a comma-delimited file with a
header line and three columns for the variance component name,
initial value and constraint code, respectively. This file can be
created using the \code{start.values = TRUE} argument; the internal list
object is then generated from the contents of this file.
}

On termination, \code{R.param} is updated with the final
\code{residual} component estimates.}
    \item{\code{na.action}}{A call to \code{na.method()} specifying the action to be taken when
missing values are encountered in the response (\code{y}) or
explanatory variables (\code{x} for factors and/or variates). The function definition for
\code{na.method} is:

\code{function(y = c("include", "omit", "fail"),}

\code{         x = c("fail", "include", "omit"))}

The default action is \code{"include"} (and estimate) missing values in
the response, and raise an error (\code{"fail"} if there are missing values
in any of the explanatory variables.}
    \item{\code{subset}}{A logical vector identifying which subset of the rows of \code{data}
should be used in the fit. All observations are included by
default.}
    \item{\code{weights}}{A character string or name identifying the column of \code{data} to
use as weights in the fit.}
    \item{\code{predict}}{A list object specifying the classifying factors and related
options when forming predictions from the model. This list would
normally be the value returned by a call to the method
\code{predict} for \code{asreml} objects.}
    \item{\code{vcm}}{A matrix defining relationships among variance parameters. The
matrix has a row for each original variance parameter and a column
for each new parameter. The default is the identity matrix, that
is, no action. See function \code{vcm.lm} for further information
and an example.}
    \item{\code{vcc}}{Equality constraints between variance parameters; a two-column
numeric matrix with a \code{dimnames} attribute. The first column
defines the \emph{grouping} structure of equated components, that
is, components within an equality \emph{group} are given the same
numeric index, and the second column contains the scaling
coefficients. The \code{dimnames()[[1]]} attribute must match the
component names in the \code{asreml} parameter vector; see
\code{start.values}.

The parameters are scaled relative to the first parameter in its
group, so the scaling of the first parameter in each group is one.

For example, the following \code{vcc} matrix:
\tabular{rr}{
1 \tab 1 \cr
2 \tab 1 \cr
2 \tab 2 \cr
3 \tab 1
}
is equivalent to the \code{vcm} matrix:
\tabular{rrr}{
1 \tab 0 \tab 0 \cr
0 \tab 1 \tab 0 \cr
0 \tab 2 \tab 0 \cr
0 \tab 0 \tab 1
}}
    \item{\code{family}}{A list of functions and expressions for defining the link and
variance functions.


Supported families are: \emph{gaussian}, \emph{inverse Gaussian},
\emph{binomial}, \emph{negative binomial}, \emph{poisson} and
\emph{Gamma}. Family objects are generated
from the \code{asreml} \link[asreml:family_dist]{family distributions} which
prefix the usual function names with \code{"asr_"}; for example
\code{asr_gaussian()}, \code{asr_binomial()}, etc. In addition to
the link argument, these functions take an additional
\code{dispersion} argument and a \code{total} argument where
relevant; for example:

\code{asr_binomial(dispersion = 1.0, total = counts)}.

The default for \code{asr_gaussian()} is \code{dispersion = NA},
which implies that \code{asreml} will estimate the dispersion
parameter, otherwise the scale is fixed at the nominated value.}
    \item{\code{asmv}}{A character string or name specifying the column in the data that
identifies the traits in a multivariate analysis. If not
\code{NULL}, \code{asmv} implies that the data for a multivariate
analysis is set up as though it were for a univariate analysis with
the response in a single variate (default = \code{NULL}).}
    \item{\code{mbf}}{A named list specifying sets of covariates to be included with one
or more \code{mbf()} model functions. Each component of the list
must in turn contain components named \code{key} and \code{cov},
where \code{cov} is a character string naming the data frame
holding the covariates, and \code{key} is a character vector of
length two naming the columns in \code{data} and \code{cov},
respectively, used to match corresponding records in the two data
frames. The default is an empty list.}
    \item{\code{group}}{A named list where each component is a numeric vector specifying
contiguous fields in \code{data} that are to be considered as a
single term. The component names can then appear in the \code{asreml} model
formulae using the \code{grp()} special function. The default is an
empty list.}
    \item{\code{equate.levels}}{A character vector of factor names whose levels are to be
\emph{equated}. For example, if factor \code{A} has levels \emph{a, b, c, d} and
factor \code{B} has levels \emph{a, b, c, e}, the effect of
\code{equate.levels(A, B)} is that both \code{A} and \code{B} have
five levels, with \code{as.numeric(A)} = \emph{1, 2, 3, 4} and
\code{as.numeric(B)} = \emph{1, 2, 3, 5}. This may be necessary if
using the \code{and()} model function to overlay columns of the
model's design matrix in forming a compound term. The default is a
zero-length character vector.}
    \item{\code{start.values}}{If \code{TRUE}, \code{asreml} exits prior to the fitting process
and returns a list of length three: the \code{G.param} and
\code{R.param} lists, and a data frame (containing variance
parameter names, initial values and boundary constraints). Initial
values or constraints can then be set in the list or data frame
objects (default = \code{FALSE}).

If this is a character string, then a file of that name is created and the
data frame object containing initial parameter values is written
out in comma-separated form. This file can be edited externally and
subsequently specified in the \code{G.param} or \code{R.param}
arguments.}
    \item{\code{knot.points}}{A named list where each component is a vector of user-supplied knot
points for a particular spline term; the component name is the
object of the \code{spl()} model function.}
    \item{\code{pwr.points}}{A named list with each component containing a vector of distances
to be used in a one-dimensional power model. The component
names must correspond to the \code{object} arguments of the power
function model terms.}
    \item{\code{wald}}{A named list with three components: \code{denDF}, \code{ssType}
and \code{Ftest}.

\itemize{

\item{\code{denDF}}{: A character string from the options: \code{"none"},
\code{"numeric"}, \code{"algebraic"}, and \code{"default"} specifying
the calculation of approximate denominator degrees of freedom. The
option \code{"none"} is to suppress the computations. Algebraic
computations are not feasible in large analyses; use
\code{"default"} to automatically choose numeric or algebraic
computations depending on problem size. The denominator degrees of
freedom are calculated according to \cite{Kenward and Roger, 1997}
for terms in the \code{fixed} model formula (default = \code{"none"}).}

\item{\code{ssType}}{: It can be \code{"incremental"} for incremental sum of
squares or \code{"conditional"} for F-tests that
respect both structural and intrinsic marginality (default = \code{"incremental"}.}

\item{\code{Ftest}}{: A one-sided formula of the form \code{~ test_term |
background_terms} specifying a conditional Wald test of the
contribution of \code{test_term} conditional on those fixed terms
listed in \code{background_terms}, and the those in the
\code{random} and \code{sparse} model formulae.}
}}
    \item{\code{prune}}{A named list with each component generated from a call to
\code{Subset()}. The argument \code{prune}, in conjunction with \code{Subset}
and the model function \code{sbs()}, forms a new factor from an
existing one by selecting a subset of its levels. The function
\code{Subset} is defined as:

\code{function(f, x)}

where \code{f} is the name of an existing factor and \code{x} is a
character or numeric vector of levels to select. The name of the
list component is the new factor that may appear in the model
formulae as the argument to the \code{sbs()} model function. For
example,

\code{prune = list(A = Subset(Site, c(2, 3)))}

creates a new factor \code{A} by selecting the second and third
levels of \code{Site}, and would be included in the model as:
\code{sbs(A)}, for example by using \code{idv(sbs(A))} as part of a random term.
While the actions of \code{prune} can be duplicated
outside \code{asreml}, \code{sbs()} is necessary if the
\code{asreml} method \code{predict()} is to be used.}
    \item{\code{combine}}{A named list with each component generated from a call to
\code{Levels()}. The argument \code{combine}, in conjunction with \code{Levels}
and the model function \code{gpf()}, forms a new factor from an
existing one by merging a subset of its levels. The function
\code{Levels} is defined as:

\code{function(f, x)}

where \code{f} is the name of an existing factor and \code{x} is a
vector of length \cr \code{length(levels(f))} defining the levels
of \code{f} to merge. The name of the list component is the new
factor that may appear in the model formulae as the argument to the
\code{gpf()} model function. For example, if \code{Site} has levels
\code{"1"}, \code{"2"} and \code{"3"},

\code{combine = list(A = Levels(Site, c("1", "2", "1")))}

creates a new factor \code{A} with levels \code{"1"} and \code{"2"}
by merging levels \code{"1"} and \code{"3"} of \code{Site}, and
would be included in the model as \code{gpf(A)}. While the actions
of \code{combine} can be duplicated outside \code{asreml},
\code{gpf()} is necessary if the \code{asreml} method
\code{predict()} is to be used.}
    \item{\code{uid}}{A named list with each component generated from a call to
\code{Units()}. The argument \code{uid}, in conjunction with \code{Units} and
the model function \code{uni()}, forms a new factor by selecting a
subset of records from an existing one. The function \code{Units} is
defined as:

\code{function(f, n = 0)}

where \code{f} is the name of an existing factor and \code{n} is a
character or numeric scalar that determines which records are
selected. The default, \code{n = 0}, forms a factor with a level for
each record where \code{f} is non-zero (strictly, \code{f} != 0).
Otherwise, a factor with a level for each record in
\code{data} where \code{f} has the value \code{n} is formed. For example,

\code{uid = list(A = Units(group, 1))}

creates a new factor \code{A} with levels from
\code{row.names(data)} where \code{group = 1}, and would be
included in the model as: \code{uni(A)}. While the actions of
\code{uid} can be duplicated outside \code{asreml}, \code{uni()} is
necessary if the \code{asreml} method \code{predict()} is to be
used.}
    \item{\code{mef}}{A named list linking a relationship matrix (or its inverse) as
specified in the \code{vm()} special function with the original
matrix of \emph{subject} x \emph{regressor} (typically molecular
marker) scores. If this is not an empty list \code{mef}
flags the computation of the \emph{regressor} (marker) effects from
the \emph{subject} effects. For example,

\code{mef = list(MM = snp.mat)}

links the relationship matrix \code{MM} to the original marker
scores found in the file \code{snp.mat}.

The \code{mef} list would typically be set from a call to the \code{asreml}
\code{meff()} method.}
    \item{\code{last}}{A named list restricting the order equations are solved in the sparse
partition for the nominated model terms. Each component of the list is
named by a model term and contains a scalar \eqn{n} specifying that
the first \eqn{n} levels of the term will be solved after all others in the
sparse set. It is intended for use when there are multiple fixed terms
in the sparse equations so that \code{asreml} will be consistent in
which effects are identified as singular. A maximum of three factor/level
pairs can be specified.}
    \item{\code{model.frame}}{If \code{TRUE}, the model frame (a \code{data.table}
object with additional attributes derived from the model
specification) is included in the returned object (default = \code{TRUE}).
The model frame is required by the \code{asreml} \code{summary},
\code{plot}, \code{resid} and \code{fitted} methods.

In large analyses, the model frame is likely to be a large
object. If \code{model.frame} is a character string, the model
frame is saved in a file as an \code{RDS} object by a call to
\code{saveRDS()}, and named by the supplied string with the
extension \code{.RDS}. If the model frame is not included in the
returned \code{asreml} object, this \code{RDS} file is searched for
by the methods noted previously.}
  }}
}
\value{
An object of class \code{asreml} containing the results of the fitted linear model.
Instances of generic methods such as \code{plot()}, \code{predict()} and \code{summary()} return
various derived results of the fit. The method \code{resid()}, \code{coef()} and \code{fitted()}
extract some of its components. See \code{\link[asreml:asreml.object]{asreml::asreml.object()}} for details of the
components of the returned list.
}
\description{
This function fits genetic-spatial competition models using \code{\link[asreml:asreml]{asreml::asreml()}}
}
\details{
A general genetic-spatial linear mixed model can be represented by:

\deqn{\mathbf{y} = \mathbf{X} \boldsymbol{\beta} + \mathbf{Z}_g \mathbf{g} + \mathbf{Z}_c \mathbf{c} + \mathbf{Z}_p \mathbf{p}  + \boldsymbol{\xi}}

where \eqn{\mathbf{y}} is the vector of phenotypic records, \eqn{\boldsymbol{\beta}}
is the vector of fixed effects, \eqn{\mathbf{g}} is the vector of direct genetic
effects (DGE), \eqn{\mathbf{c}} is the vector of indirect genetic effects (IGE),
\eqn{\mathbf{p}} is the vector of other random effects,
and \eqn{\boldsymbol{\xi}} is the vector of spatially correlated errors.
\eqn{\mathbf{X}} is the incidence matrix of the fixed effects, \eqn{\mathbf{Z}_g}
is the DGE incidence matrix, \eqn{\mathbf{Z}_c} is the IGE incidence matrix (built
using \link{prep}), and \eqn{\mathbf{Z}_p} is the design matrix of
other random effects. The dimensions of \eqn{\mathbf{Z}_c} are the same
as \eqn{\mathbf{Z}_g}. The spatially correlated errors are distributed as
\eqn{\boldsymbol{\xi} \sim N\{\mathbf{0}, \sigma^2_\xi[\mathbf{AR1}(\rho_C) \otimes \mathbf{AR1}(\rho_R)]\}},
where \eqn{\sigma^2_\xi} is the spatially correlated residual variance,
\eqn{\mathbf{AR1}(\rho_C)} and \eqn{\mathbf{AR1}(\rho_R)} are the first-order autoregressive
correlation matrices in the column and row directions, and \eqn{\otimes} is the
Kronecker product. If \code{cor = TRUE}, the function will fit a model in which
\eqn{\mathbf{g}} and \eqn{\mathbf{c}} are correlated outcomes of the genotypic effects
decomposition. They both follow a Gaussian distribution, with mean centred in zero, and
covariange given by:

\deqn{\mathbf{\Sigma_g}=  \begin{bmatrix}\sigma_{\text{g}}^2 & \sigma_{\text{gc}}\\\sigma_{\text{gc}} & \sigma_{\text{c}}^2\\\end{bmatrix}\otimes {{\mathbf I_V}}}

where \eqn{\sigma_{\text{g}}^2} is the DGE variance, \eqn{\sigma_{\text{c}}^2} is the IGE variance,
and \eqn{\sigma_{\text{gc}}} is the covariance between DGE and IGE.

If the dataset has multiple ages, the model described aboved is expanded with two more effects:
the DGE \eqn{\times} age interaction, and the IGE \eqn{\times} age interaction. A further \eqn{\mathbf{AR1}}
matrix is added to the residual covariance structure in a three-way autoregressive process:
\eqn{\mathbf{AR1}(\rho_A) \otimes \mathbf{AR1}(\rho_C) \otimes \mathbf{AR1}(\rho_R)}

The likelihood ratio test is performed using a model without the correlation between DGE and IGE.
}
\examples{
\donttest{
 library(gencomp)
 comp_mat = prep(data = euca, gen = 'clone', repl = 'block', area = 'area',
                 ind = 'tree', age = 'age', row = 'row', col = 'col', dist.col = 3, 
                 dist.row = 2, trait = 'MAI', method = 'SK', n.dec = 3, verbose = TRUE)
 
 model = asr(prep.out = comp_mat, 
             fixed = MAI~ age, 
             random = ~ block:age, 
             cor = TRUE, maxit = 50,
             lrtest = FALSE)
 }
}
\seealso{
\link{prep}, \link[asreml:asreml.options]{asreml::asreml.options}, \link[asreml:asreml.object]{asreml::asreml.object}, \link[asreml:family_dist]{asreml::family_dist}
}
